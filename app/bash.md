# Linux bash 操作方法のメモ

一部だが、頭に入れておくと操作が捗る？

|   キー   |                     動作                     |
| :------: | :------------------------------------------: |
| Ctrl + a |                  行頭に移動                  |
| Ctrl + e |                  行末に移動                  |
| Alt + f  |                右の単語に移動                |
| Alt + b  |                左の単語に移動                |
| ctrl + k |       カーソル位置から行末まで切り取り       |
| ctrl + u |       カーソル位置から行頭まで切り取り       |
| ctrl + y |           切り取った文字の貼り付け           |
| ctrl + r |    過去のコマンドをインクリメンタルサーチ    |
| ctrl + s |               端末をロックする               |
| ctrl + q | ロック状態から復帰 (ctrl + s 誤爆の際に使用) |

コマンドのインクリメンタルサーチは部分一致検索ではあるが正規表現は不可らしい。  
少なくとも当方端末では無理だった。
## コマンド履歴検索中の操作

長ったらしいコマンドは履歴から実行したほうが合理的。

|   キー   |                    動作                    |
| :------: | :----------------------------------------: |
|  right   | 選択中のコマンドを入力する（実行はしない） |
|  enter   |         選択中のコマンドを実行する         |
| ctrl + r |                 履歴を遡る                 |
| ctrl + s |                履歴を進める                |
# Linux bash コマンドに関するメモ

## find

ファイルを検索するコマンド。再帰的に指定ディレクトリ内を検索してくれる。

### 標準的使用例

	find -name "*.txt"

`.txt` のファイルを検索している。名前で検索するには -name 引数が必要になる模様。  
ファイルサイズや更新日時等のあらゆる条件で検索が可能なコマンドであるため、条件を明示する必要があるためと思われる。  
また、当方環境ではファイル名指定は二重引用符なしでは反応しない？

以下は検索ディレクトリを指定する場合の書式。[startPoint] が検索を開始するディレクトリ。  
これを省略した場合はカレントディレクトリを開始点と見做すとのこと。

	find [startPoint] -name "*.txt" 

### 他のコマンドと組み合わせて使用した例

	find -name "*.txt" | grep -e '[0-9]' | xargs -I{} mv {} {}suffix

以下説明

1. 複数のディレクトリ内に散らばるテキストファイルを検索。
2. 標準出力を `grep` に渡して、数字が含まれるファイル名を抽出。
3. `grep` の出力を `xargs` に渡し、`mv` を実行。  
4. `grep` で抽出されたファイル名の後ろに suffix が加わる。

複数フォルダに散らばっている特定の名前のファイルを集めるために使用。(ファイル名に文字列を加えてエクスプローラーで検索)  
二度と使うことはない気がするけど記念に記録しておく。

find で正規表現による検索が可能ならもう少し簡略化できたが、このコマンドで正規表現を利用するのはどうにも面倒そう。

曰く、正規表現のタイプの設定が必要だとか、部分一致は不可だとか（部分一致に関しては `.*` とか使えばでも問題はなさそうだが……）

結論は `grep` を使ったほうが早い。

## grep

### 基本書式  
`grep [オプション] [対象文字列]`

検索文字列に関しては、特に "" で囲ったりする必要はない(但し空白が入る場合は別だと思われる。)

### 使用例
`grep 検索文字列 test.txt`

### OR 検索
`grep -e 検索文字列1 -e 検索文字列2 test.txt`

### フォルダ以下のファイルを検索
`grep -r 検索文字列 対象フォルダ`

## 使いそうなオプション

-i 大文字と小文字を無視  
-o 一致した文字列のみを表示（無指定はマッチした行全体を表示）  
-v 一致しなかったものを表示する。  
-n 一致した文字列の行番号を一緒に表示する。

## 便利コマンド

### 検索した文字列に番号を振って出力する。
`grep 検索文字列 test.txt | nl`

### 上記+行番号+マッチした回数(0詰め3桁)
`grep -n 検索文字列 test.txt | nl -w3 -nrz`

### 行末にセミコロンがついてない箇所を検索（ディレクトリ）
`grep -ve \;.$ -ve {.$ -ve }.$ -ve ^.$ -ve // -ve "\*\*" -ve "^\s*\*" -r directoryName | less`

余談:行末にセミコロンをつけ忘れている箇所を検索しようとしたときに、行末の一字と行末の間に何らかの文字が入っているらしい。  
検索したファイルは .as で、コードフォーマッターを使用していたけど何か挿入されてる？

## ls

### 使いそうなオプション

-1 ファイルを１行１つの表示にする。  
-a ドットファイルも含めてファイルを表示する。

--ignore=pattern パターンにマッチするファイルを非表示にする。xargs とかの組み合わせが強力。  
使用例 以下はテキストファイルを非表示にする。

`ls --ignore=*.txt`

### lsの出力をフルパスを表示

	並列表示でフルパス
	ls `pwd`/*
	
	１行１ファイルでフルパス
	ls -1 `pwd`/*

ls コマンドの引数に `directory/*` の書式でパスを入力すると、そのディレクトリ名も含めて内部のファイルを表示する。  
これを利用して pwd をバッククォートで括り（コマンドとして認識させる）入力することで現在のディレクトリのファイルをフルパス表示する。
## cat

ファイルを表示するコマンド。複数指定可。以下使用例。

`cat a.txt b.txt c.txt`

ファイルの中身を確認するだけなら less コマンドの方が便利。  
主にファイルの中身を標準出力に出して、ファイルやクリップボードにリダイレクトする際に使用する。  
複数のテキストファイルを一つに連結したりもできる。知ってるとちょっとした作業が楽になるコマンド。

以下のコマンドは a.txt の内容を dest.txt に追記する。余談だが、上書きの場合は '>' を使う。

`cat a.txt >> dest.txt`

### 使いそうなオプション
-n 行番号をつける。  
-b 同じく行番号をつけるが、空白をカウントしない。  
-s 連続した空行を１行にまとめて表示。  

## xargs

標準出力を後に続くコマンドの引数にわたすコマンド。知ってると便利。

`ls | xargs cat`

ls によってファイル一覧が出力され、出力されたファイル名が cat コマンドの引数として渡される。  
上記コマンドの内容をファイルにリダイレクトすれば、ファイルを結合したりもできる。

### -I オプション

`ls | xargs -I{} echo {} FileOrDirectory`

xargs は受け取った出力を後続のコマンドに渡すが、`-I` オプションを使用すると、後続のコマンドに任意の文字列を渡せる。  
上記の `-I{}` の中括弧の部分が xargs が受け取った出力。(今回は一例として中括弧だが、ここは任意の文字列を指定できる。)  
echo に渡す際に中括弧を記述すると、`echo` 実行時に中括弧が xargs が受け取った文字列に置き換えられる。
上記を実行すると、

```
fileNameA FileOrDirectory
fileNameB FileOrDirectory
...
```

のような出力がコンソールに並ぶ。  
find でファイル一覧を出力して、見つかったファイルを全て特定のディレクトリに移動させる。といったことが可能。

## patch

ファイルの変更を出力して、別のディレクトリに適用するコマンド。自分は git とセットで使用。  
まずは、 git diff コマンドの出力をファイルにリダイレクトする。拡張子は別に無くても可。わかれば良い。

	$ git diff > diff.patch
	
diff.patch が変更を保存したファイルなるので、それを変更を適用したいディレクトリに置く。

	$ patch -p1 < diff.patch
	
パッチコマンドに diff.patch を入力すれば適用できる。p1 オプションに関しては、diff.patch に記述されている

	--- dir0/dir1/dir2
	
のパスの部分を指定した数値分無視するオプションらしい。  
つまり p1 で指定した場合は 上記で言えば、dir0 が無視される。  
git diff の場合はパスの前に `a/ b/` といったディレクトリが入るため、1 を指定していると理解。  
これが 0 だと、git を使用した今回のケースでは動作しなかった。

### エラーが出た場合

適用の際にエラーが出たので書き留める。出たエラーが以下。

	patching file fileName
	Hunk #1 FAILED at 01 (different line nedings).

パッチの適用失敗。リポジトリに `.orig .rej` ファイルが生成された。  
今回のケースでは、適用先とパッチファイルの改行コードの違いが問題だったらしいが、改行コードの修正では問題を解決できず。

	$ patch -p1 --binary < diff.patch
	
で解決。 `--binary` は、ファイルをバイナリモードで読み書きすることのこと。  
バイナリファイルで読み書きは理解できるけど、何故これで改行コードの問題が解決すのかは不明。
